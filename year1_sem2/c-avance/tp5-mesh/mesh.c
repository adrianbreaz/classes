#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "mesh.h"

#define MAXLINESIZE 256

/*
 *
 * LOCAL HELPER FUNCTIONS
 *
 */

/* Computes the length of a segment with the well known formula:
 *      length = \sqrt{ (x1 - x2)^2 + (y1 - y2)^2 }
 */
double edge_length(const edge_t edge)
{
    node_t *n1 = edge.up;
    node_t *n2 = edge.down;

    double dx = n1->x - n2->x;
    double dy = n1->y - n2->y;
    return sqrt(dx * dx + dy * dy);
}

/* Computes the area of a irregular polygon with any number of nodes with the
 * following formula:
 *      area = \frac{1}{2} * (x_1 * y_2 - x_2 * y_1 + ... + x_n * y_1 - x_1 * y_n)
 *
 * http://mathworld.wolfram.com/PolygonArea.html
 */
double cell_area(const cell_t cell)
{
    int i;
    int j = cell.nb_nodes - 1;
    double area = 0.0;

    for(i = 0; i < cell.nb_nodes; i++)
    {
        area += cell.node[j]->x * cell.node[i]->y - cell.node[i]->x * cell.node[j]->y;
        j = i;
    }

    return area / 2;
}

/* read all the nodes from a name.node file generated by the TRIANGLE app */
void read_nodes(mesh_t *mesh, const char *filename)
{
    int id, x, y, b;
    int nb_attrs, border;

    FILE *fd;
    char buf[MAXLINESIZE];

    fd = fopen(filename, "r");

    /* first read the 'header' */
    fscanf(fd, "%d %d %d %d", &(mesh->nb_nodes), &(mesh->dim), &nb_attrs, &border);

    mesh->node = (node_t *)malloc(sizeof(node_t) * mesh->nb_nodes);

    /* TODO: find out what's the deal with the attributes and read them */
    while(fgets(buf, MAXLINESIZE, fd) !=  NULL)
    {
        /* TODO: this is incredibly short-sighted */
        sscanf(buf, "%d %lg %lg %d", &id, &x, &y, &b);

        mesh->node[id].x = x;
        mesh->node[id].y = y;
        mesh->node[id].nb_attrs = nb_attrs;
        mesh->node[id].attr = NULL;
        /* NOTE: does the border field only exist if the initial border flag is 1? */
        mesh->node[id].border = b;
    }

    fclose(fd);
}

/* read all the edges from a name.edge file generated by the TRIANGLE app */
void read_edges(mesh_t *mesh, const char *filename)
{
    int id, n1, n2, b;
    int border;

    FILE *fd;
    char buf[MAXLINESIZE];

    fd = fopen(filename, "r");

    /* first read the 'header' */
    fscanf(fd, "%d %d", &(mesh->nb_edges), &border);

    mesh->edge = (edge_t *)malloc(sizeof(edge_t) * mesh->nb_edges);

    /* TODO: this reading thing needs to be made more robust, probably not
     * necessary for this exercise though.
     */
    while(fgets(buf, MAXLINESIZE, fd) != NULL)
    {
        sscanf(buf, "%d %d %d %d", &id, &n1, &n2, &b);

        mesh->edge[id].up = &(mesh->node[n1]);
        mesh->edge[id].down = &(mesh->node[n2]);
        mesh->edge[id].border = b;
        mesh->edge[id].length = edge_length(mesh->edge[id]);
    }

    fclose(fd);
}

/* read all the cells from a name.ele file generated by the TRIANGLE app */
void read_cells(mesh_t *mesh, const char *filename)
{
    int id, n1, n2, n3;
    int nb_attr, nb_nodes;

    FILE *fd;
    char buf[MAXLINESIZE];
    int i;

    fd = fopen(filename, "r");

    /* first read the 'header' */
    fscanf(fd, "%d %d %d", &(mesh->nb_cells), &nb_nodes, &nb_attr);

    mesh->cell = (cell_t *)malloc(sizeof(cell_t) * mesh->nb_cells);

    /* TODO: get list of edges as well */
    while(fgets(buf, MAXLINESIZE, fd) != NULL)
    {
        sscanf(buf, "%d %d %d %d", &id, &n1, &n2, &n3);
        mesh->cell[id].node = (node_t **)malloc(sizeof(node_t *) * nb_nodes);
        mesh->cell[id].nodes_id = (int *)malloc(sizeof(int) * nb_nodes);

        /* TODO: should really find a way to do this more generally */
        mesh->cell[id].node[0] = &(mesh->node[n1]);
        mesh->cell[id].nodes_id[0] = n1;

        mesh->cell[id].node[1] = &(mesh->node[n2]);
        mesh->cell[id].nodes_id[1] = n2;

        mesh->cell[id].node[2] = &(mesh->node[n3]);
        mesh->cell[id].nodes_id[2] = n3;

        mesh->cell[id].edge = NULL;
        mesh->cell[id].nb_nodes = nb_nodes;
        mesh->cell[id].area = cell_area(mesh->cell[id]);
    }

    fclose(fd);
}

/*
 *
 * FUNCTIONS DEFINED IN THE HEADER
 *
 */
mesh_t *init_mesh()
{
    mesh_t *mesh;
    mesh = (mesh_t *)calloc(1, sizeof(mesh_t));

    return mesh;
}

void free_mesh(mesh_t *mesh)
{
    int i, j;

    /* nothing to do, no one to see*/
    assert(mesh == NULL);

    /* there have to be some! please! */
    if(mesh->node)
    {
        /* delete all attributes, only if we have any */
        /* NOTE: number of attributes is set globally so if the first one doesn't have
         * any, none of them do.
         */
        for(i = 0; i < mesh->nb_nodes && mesh->node[0].nb_attrs; i++)
        {
            if(mesh->node[i].attr)
            {
                for(j = 0; j < mesh->node[i].nb_attrs; j++)
                    free(mesh->node[i].attr[j]);
            }
        }

        free(mesh->node);
    }

    /* maybe we have better luck here, although if we have no node we should have no edges */
    if(mesh->edge)
    {
        free(mesh->edge);
    }

    /* yeah. better safe than sorry */
    if(mesh->cell)
    {
        /* stupid dynamic number of nodes and stuff */
        /* NOTE: number of nodes (edges) of a cell is set globally so if one doesn't
         * have any, none of them do.
         */
        for(i = 0; i < mesh->nb_cells && mesh->cell[0].nb_nodes; i++)
        {
            if(mesh->cell[i].node)
                free(mesh->cell[i].node);
            if(mesh->cell[i].edge)
                free(mesh->cell[i].edge);
        }

        free(mesh->cell);
    }

    /* finally! */
    free(mesh);
}

void read_data(mesh_t *mesh, const char *file_basename)
{
    /* length is: basename + .1.extension (always 6 or 7 chars) + '\0' */
    int len = strlen(file_basename) + strlen(".1.extn") + 1;
    char *tmpfile;
    tmpfile = (char *)malloc(sizeof(char) * len);

    /* NOTE: any reason to use strncpy and strncat here? */
    /* First we read all the nodes because they're small */
    strcpy(tmpfile, file_basename);
    strcat(tmpfile, ".1.node");
    read_nodes(mesh, tmpfile);

    /* Then all the edges because we needed the nodes to form edges */
    strcpy(tmpfile, file_basename);
    strcat(tmpfile, ".1.edge");
    read_edges(mesh, tmpfile);

    /* Stupid interdependecies */
    strcpy(tmpfile, file_basename);
    strcat(tmpfile, ".1.ele");
    read_cells(mesh, tmpfile);

    /* over! */
    free(tmpfile);
}

void write_data_to_vtk(mesh_t *mesh, const char *dst_file)
{
    FILE *fd;
    int i;
    int cell_nodes = mesh->cell[0].nb_nodes;

    fd = fopen(dst_file, "w");

    fprintf(fd, "# vtk DataFile Version 3.1\n");
    fprintf(fd, "# special file for triangular meshes\n");
    fprintf(fd, "# ASCII\n");
    fprintf(fd, "# DATASET UNSTRUCTURED_GRID\n\n");
    fprintf(fd, "# POINTS %d FLOAT\n", mesh->nb_nodes);

    for(i = 0; i < mesh->nb_nodes; i++)
        fprintf(fd, "%g %g %d\n", mesh->node[i].x, mesh->node[i].y, 0);

    fprintf(fd, "\nCELLS %d %d\n", mesh->nb_cells, 4 * mesh->nb_cells);

    for(i = 0; i < mesh->nb_cells; i++)
        fprintf(fd, "%d %d %d %d\n", cell_nodes, mesh->cell[i].nodes_id[0], \
                                                 mesh->cell[i].nodes_id[1], \
                                                 mesh->cell[i].nodes_id[2]);

    fprintf(fd, "\nCELL_TYPES %d\n", mesh->nb_cells);
    for(i = 0; i < mesh->nb_cells; i++)
        fprintf(fd, "5 ");
    fprintf(fd, "\b\n");

    fclose(fd);
}